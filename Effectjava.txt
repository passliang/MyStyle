	1.创建销毁对象
	1.1可以使用静态工厂方法代替构造器（优点1.拥有名称2.不必每次调用时候都创建新新的对象3.可以返回原返回类型的任何子类型的对象4.创建参数化类型实例的时候，可以使代码变得简单。缺点 1.类如果不包含公有的或者受保护的构造器，就不能被子类化2.与静态方法实际没啥区别）
	1.2遇到多个构造器参数时要考虑使用构造器（多个参数时考虑使用builder模式）
	1.3用私有构造器或者枚举类型强化singleton属性 （final，静态工厂类，枚举类型）
	1.4通过私有构造器强化不可实例化能力
	1.5避免创建不必要的对象
	1.6消除过期的对象引用（heap剖析工具 Heap Profiler）例如可能引起内存泄漏 OutOfMemory
	1.7避免使用终结方法（java语言规范不仅不保证终结方法会被及时执行，而且根本就不会保证他们会执行）不要依赖终结方法来更新重要的持久状态（例如释放共享资源（比如数据库）上的永久锁 ，容易使系统垮掉）System.gc 和System.runFinalization两个方法 增加了终结方法执行机会但是并不能保证终结方法一定执行。唯一保证终结方法执行的方法 System.runFinalizersOnExit 和 Runntime.runFinalizersOnExit 两个方法（存在致命缺陷 已经废弃）
	1.8覆盖equals遵守约定(1.类实例都是唯一的2.不关心是否提供了逻辑相等的测试功能3.超类已覆盖equals 从超类继承过来的应为对于子类也是合适的 4.类私有或者包私有,可以确定他的equals方法永远不会被调用（覆盖equals方法防止为意外调用）2.object的规范 自反性（非null的引用值 x.equals（x）必须返回true 2.对称性 对于任何非null的引用值 x,y y.equals(x)为true 则x.equals（y）必须返回false 3.传递性 对于任何非null引用值x,y,z 如果x.equals（y）返回true 并且y.equals（z）返回true  那么 x.equals(z）必须返回true) 4.一致性 任何非null的x,y比较操作过程中没有被修改 就应该一致返回一致结果) 技巧 1.使用==判断参数是否为这个对象引用2.使用instanceof操作符检查参数是否为正确类型3.将参数转化为正确的类型4.对于该类中的每个关键域检查参数中的域是否与该对象中的对应域相匹配5.是否是对称性的 传递的一致的
	1.9覆盖equals总是要覆盖hashcode 
	2.0始终覆盖toString()
	2.1谨慎覆盖clone
	2.2考虑实现compareable接口 compareTo  允许简单的的等同性比较，并且允许执行顺序比较  与equals方法类似 属于是一个泛型
	2.3使类和成员可访问性最小化	
	2.4在公有类中使用访问方法而非公有域
	2.5使可变性最小化（1.不要提供任何会修改对象的方法2.保证类不会被扩展3.使所有的域都是final的4.使所有的域都是私有的5.确保对于任何可变的组件的互斥访问）
	2.6复合优先于继承
	2.7要不为继承而设计 并提供文档说明要么禁止继承
	
	永远不要让客户去做任何类库能够替代客户完成的事情
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	